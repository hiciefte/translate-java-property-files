services:
  translator:
    # Use environment variables to make container and volume names unique per instance
    container_name: ${CONTAINER_NAME:-translator-service}
    build:
      context: .. # Build context is the project root
      dockerfile: docker/Dockerfile # Path to Dockerfile from project root
    # The entrypoint is defined in the Dockerfile.
    # By default, run the main orchestration script. Can be overridden for debugging.
    command: ["/app/update-translations.sh"]
    volumes:
      # Mount the Docker-specific config to the default config path in the app
      - ./config.docker.yaml:/app/config.yaml:ro
      # Mount the glossary file (located in project root)
      - ../glossary.json:/app/glossary.json:ro
      # Mount SSH keys from host user's home (read-only for appuser)
      - ${HOME}/.ssh:/home/appuser/.ssh:ro
      # Mount logs directory (in project root) for persistence
      - ../logs:/app/logs
      # Mount a named volume for the target repository to persist it across restarts
      - ${VOLUME_NAME:-target-repo-data}:/target_repo
    # The container will start as root, and the entrypoint script will drop privileges to 'appuser'.
    # This allows the entrypoint to fix volume permissions before the main application runs.
    env_file:
      - .env
    # Note: Place the .env file alongside this compose file (docker/.env)
    # with API keys and HOST_UID/GID.
    # An example is provided in docker/.env.example

# Define the named volume. The name used here is the default.
# The ${VOLUME_NAME} environment variable in the service's volumes section
# can still point to a differently named volume if needed.
volumes:
  target-repo-data: 